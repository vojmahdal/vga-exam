m_program->addShaderFromSourceCode(QOpenGLShader::Vertex,
"attribute highp vec4 posAttr;\n"
"attribute lowp vec4 colAttr;\n"
"varying lowp vec4 col;\n"
"\n"
"uniform highp mat4 matrix;\n"
"uniform highp mat4 prevMatrix;\n"
"\n"
"void main() {\n"
"   vec4 finalColor = colAttr;\n"
"\n"
"   // ------------------------\n"
"   // ğŸ’  1. Posun (translace)\n"
"   // ------------------------\n"
"   // ÄŒtvrtÃ½ sloupec matice obsahuje posun objektu (Tx, Ty, Tz)\n"
"   bool isTranslating = distance(matrix[3], prevMatrix[3]) > 0.0001;\n"
"\n"
"   // ------------------------\n"
"   // ğŸ” 2. Rotace (zmÄ›na v orientaci)\n"
"   // ------------------------\n"
"   // PorovnÃ¡vÃ¡me hornÃ­ 3x3 ÄÃ¡st matice (rotace, moÅ¾nÃ¡ i scale)\n"
"   bool isRotating = false;\n"
"   for (int i = 0; i < 3; ++i) {\n"
"       for (int j = 0; j < 3; ++j) {\n"
"           if (abs(matrix[i][j] - prevMatrix[i][j]) > 0.0001) {\n"
"               isRotating = true;\n"
"           }\n"
"       }\n"
"   }\n"
"\n"
"   // ------------------------\n"
"   // ğŸ” 3. Å kÃ¡lovÃ¡nÃ­ (scale)\n"
"   // ------------------------\n"
"   // VypoÄÃ­tÃ¡me dÃ©lky osovÃ½ch vektorÅ¯ z hornÃ­ 3x3 ÄÃ¡sti\n"
"   float scaleX = length(vec3(matrix[0].x, matrix[0].y, matrix[0].z));\n"
"   float scaleY = length(vec3(matrix[1].x, matrix[1].y, matrix[1].z));\n"
"   float scaleZ = length(vec3(matrix[2].x, matrix[2].y, matrix[2].z));\n"
"   bool isScaled = abs(scaleX - 1.0) > 0.01 || abs(scaleY - 1.0) > 0.01 || abs(scaleZ - 1.0) > 0.01;\n"
"\n"
"   // ------------------------\n"
"   // ğŸ”§ 4. ZkosenÃ­ (shear)\n"
"   // ------------------------\n"
"   // Pokud osy nejsou kolmÃ©, je ve scÃ©nÄ› shear (napÅ™. X a Y nejsou kolmÃ©)\n"
"   float shearXY = dot(normalize(matrix[0].xyz), normalize(matrix[1].xyz));\n"
"   bool isSheared = abs(shearXY) > 0.01;\n"
"\n"
"   // ------------------------\n"
"   // ğŸ”ƒ 5. PÅ™evrÃ¡cenÃ­ / zrcadlenÃ­ (determinant < 0)\n"
"   // ------------------------\n"
"   // Jestli je matice â€pÅ™evrÃ¡cenÃ¡â€œ (napÅ™. zrcadlenÃ¡ nebo obrÃ¡cenÃ¡)\n"
"   float det = \n"
"       matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]) -\n"
"       matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0]) +\n"
"       matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);\n"
"   bool isMirrored = det < 0.0;\n"
"\n"
"   // ------------------------\n"
"   // ğŸ¨ Barva podle transformace\n"
"   // ------------------------\n"
"   if (isTranslating) {\n"
"       // ZtmavÃ­me barvu o 30 %\n"
"       finalColor.rgb *= 0.7;\n"
"   }\n"
"\n"
"   if (isRotating) {\n"
"       // SmÃ­chÃ¡me s modrou barvou 50 % prÅ¯hlednost\n"
"       finalColor = mix(finalColor, vec4(0.0, 0.0, 1.0, 0.5), 0.5);\n"
"   }\n"
"\n"
"   if (isScaled) {\n"
"       // ZvÃ½raznÃ­me zelenou sloÅ¾ku\n"
"       finalColor.g += 0.3;\n"
"   }\n"
"\n"
"   if (isSheared) {\n"
"       // ZbarvÃ­me do fialova\n"
"       finalColor.rgb = mix(finalColor.rgb, vec3(0.5, 0.0, 0.5), 0.5);\n"
"   }\n"
"\n"
"   if (isMirrored) {\n"
"       // Invertujeme barvu (negativ)\n"
"       finalColor.rgb = vec3(1.0) - finalColor.rgb;\n"
"   }\n"
"\n"
"   col = finalColor;\n"
"   gl_Position = matrix * posAttr;\n"
"}\n");

m_program->addShaderFromSourceCode(QOpenGLShader::Fragment,
"varying lowp vec4 col;\n"
"\n"
"void main() {\n"
"    gl_FragColor = col;\n"
"}\n");